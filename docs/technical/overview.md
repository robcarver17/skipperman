This document gives a technical overview of the system. 

# flask_app

This is a flask app, and the entry points are via [`flask_app.py`](/flask_app.py). The following entry points are always accessible from the 'orange bar':

- login: displays the template `login_page.html`
- logout: logs the user out and displays the main menu page 
- change password: displays the template `change_password.html`
-  link_login: allows a user to login via a link (useful when password reset)

The following entry points modify state and then returns the main menu page (it's only accessible from the main menu page):

- set_read_only_local: toggle local read only access on or off
- set_read_only_global: toggle global read only access on or off (doesn't actually change state but creates or destroys a marker file)
- make_backup: backups data to a [snapshot](/docs/data_backup_help.md)

The following entry point generates HTML from documentation markdown .md files:

- help: Help pages. Uniquely, these are opened in a new window. 

The error pages display the error and then the main menu:
- generic_web_error (500 errors)
- generic_missing_page_error (400 errors)

The following entry points generate HTML with python:

- main_menu: The main menu page. This only shows options that are available given user privileges. If logged out, only the 'orange bar' heading is shown.
- Action pages eg `.../action/view_list_of_events`. Once within an action page state data is used to identify the precise page to be served.


# HTML and CSS

## HTML templates

A small number of Flask templates are used for logging in and out, and changing the user password.

## Master layout

The project makes very limited use of flask templates, instead it uses a mixture of hard coded HTML and HTML generated from proprietary python by parsing a set of abstract objects that each represent a typical piece of content.

All the entry points that generate HTML with python (main menu, help, and action pages) call [`get_master_layout`](/app/web/html/master_layout.py)
`get_master_layout` uses the following CSS sheets, adapted from those provided by `https://www.w3schools.com/`:

- `/static/w3.css`
- `/static/w3-theme-black.css`
- `/static/font-awesome.min.css` (has a dependency on `fontawesome.io`)

The 'orange bar' is generated by [/app/web/html/heading.py](/app/web/html/heading.py) which currently contains hard coded HTML, this also generates the 'flash block' - a black block of important messages generated in the previous action.

## Help pages: Generated HTML from markdown

A page with the link `/help/X` will resolve to displaying them HTML conversion of the markdown file `/docs/help/X.md`, and by convention with the exception of the main manu page should have the suffix `_help`. This uses the standard python markdown library. It is wrapped in the HTML generated by `get_master_layout`.

## Generated HTML from proprietary abstract objects

Both the main menu and 'action' pages generate a list of abstract objects which are then translated to HTML by `app/web/html/process_abstract_form_to_html.py`, which is then is wrapped in the HTML generated by `get_master_layout` before display. The only difference is that action page contents are wrapped inside an HTML form.

# Generated HTML pages

## Main menu page

Skipperman pages consist of the orange header, a grey 'nav bar', plus content. For the main menu the nav bar contains only the help button, plus a series of large tiled menu options. The menu options available depend on the user access. Each hard links to an action page. The available menu options, with mapping to action pages plus security permissions, is contained in [`menu_define.py`](/app/frontend/menu_define.py) .

## Action pages

Action pages also consist of a grey 'nav bar' which at a minimum will include an option to return to the main menu; plus further content. Once within a given action (eg 'Events') the page URL remains fixed, and what is displayed depends on state. Therefore, each action is a self contained mini website. 

The HTML for action pages is generated by `app/web/actions/action_pages.py`. Initially, this uses the `get_abstract_form_for_specific_action` method of the `SiteActions` class. If an abstract File object is returned, then it returns a file. Otherwise, the abstract objects are again converted into HTML and then wrapped in the master layout.

### Getting the abstract form for an action

To get the abstract form for an action, we first create a `FlaskInterface`. An `abstractInterface` is a base class by which the business logic can interact without knowing it is producing HTML, running in a flask system, or how it is accessing data. Methods the interface needs to supply include accessing data and cached data, logging errors, providing access to persistent state, finding out the values passed when a form is filled in, and so on. The `FlaskInterface` is the single implementation of `abstractInterface` that provides access to these various services using flask. 

The `FlaskInterface` takes as it's arguments:
- object_store: which provides access to caching and the underlying data (which is currently stored in .csv files but this could be replaced with a database)
- the *form mapping* of type `DisplayAndPostFormFunctionMaps` for this specific action. A form mapping dictates which functions are called on the GET and POST HTTP request methods for the initial action page, and defines the tree of such functions within an action. This is required so that sub action pages know who their parent page is, and so the initial call can find the ultimate parent page producing function for the relevant action (i.e. for 'Cadets' menu option, it shows a list of all the cadets. Sub-options such as adding a cadet will return to this parent once completed).
- Optionally, the name of the action being called (there are some instances when we create a `FlaskInterface` without an attached action) 

Once we create the `FlaskInterface`, we use this to create a `FormHandler`. This manipulates the underlying interface to navigate between forms. The `get_form` method is the entry point to determine which form is returned, depending on the underlying state.

### An example of what happens with an action - inside FormHandler

It might be worth quickly running through what happens when a specific action page is displayed from the main menu. This will be helpful if you are unfamiliar with Flask, and will expose more of the internals. Assume we begin by click on the 'Sailors' button on the main menu, which redirects the url to `/action/view_master_list_of_cadets`

1- The flask server goes to `flask_app.py` and works out what to do depending on the URL that is passed, eg `/action/view_master_list_of_cadets`
2- This code `@app.route("/%s/<action_option>" % ACTION_PREFIX, methods=["GET", "POST"])` indicates that if `/action/` (which is ACTION_PREFIX) is at the start of the URL path, then we call the following function, passing the tail of the URL as the argument `action_option` (which will be `view_master_list_of_cadets` in this case) as a variable
3- The function `action(action_option)` is called, which calls [`generate_action_page_html(action_option)`](/app/web/end_points/action_pages.py) after a security check
4- We call `get_abstract_form_for_specific_action` to get the abstract objects to convert to an HTML form
  - We get a `FormHandler` for the specific action
    - We create a `FlaskInterface`, including the default data access option
      - We find the appropriate form mapping dictionary for this action
  - We call the `get_form` method of the form handler
  - This works out if we are doing a GET ('displayed form') or POST ('posted form'). On this first call we are doing a GET
    - It looks up the appropriate function to call to get the displayed form, from the form mapping dictionary (which for the Cadet actions is `app/logic/cadets/cadet_function_mapping.py`). As we have no state information, this will be the 'initial form' for which the appropriate function here is `app.frontend.cadets.ENTRY_view_cadets.display_form_view_of_cadets`
    - That function returns an abstract `Form`
5- The abstract `Form` is converted into an HTML form by `from_abstract_to_laid_out_html`
6- This is then wrapped in the master layout and returned to the client by the flask server

What happens if we then click on a button, say 'Add cadet'?

1 - We use the same flask endpoint, as the URL is unchanged and this is still an action
2- As a button has been pressed, this is now a POST
3 -`action(action_option)` is called
4 - ... the early steps remain the same
  - We call the `get_form` method of the form handler
  - This works out if we are doing a GET ('displayed form') or POST ('posted form'). We are now doing a POST, so we look for the posted form.
    - It looks up the appropriate function to call to get the posted form, from the form mapping dictionary. As we still have no state information, this will be the 'initial form' for which the appropriate function here is `app.frontend.cadets.ENTRY_view_cadets.post_form_view_of_cadets`
    - That function returns an abstract `NewForm`, which is a simple object that when returned sets the state information so that we know we have moved to a different page within this action.  
  - We then redirect to the display form name specified by the `NewForm`, which should also be in the form mapping. From here we proceed as if we are getting the function for a displayed form above.  

Steps 5 and 6 are the same.

After any further buttons are pressed, the state information will now reflect that we are in the 'add cadets' form, and behave accordingly. Note that except for the initial display of the view cadets entry form for the action, we will always be getting a POST request as a button will have been pressed, but these will almost always redirect to a 'display' form. There are also special procedures if a 'finished' button is pressed (this happens at the end of an operation), which returns us to the initial state form for this action (in this case looking at all cadets). We clear all state information when doing this.

